<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Family Accounts ‚Äî Updated</title>
  <style>
    :root{
      --bg:#f6f8fb; --card:#ffffff; --muted:#64748b; --text:#0f172a;
      --accent:#2563eb; --ok:#16a34a; --bad:#dc2626; --chip:#eef2ff; --border:#e5e7eb;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:linear-gradient(180deg,#f8fafc,#ffffff);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif}
    .wrap{max-width:980px;margin:0 auto;padding:16px}

    /* Header (clean text only) */
    .header{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap; padding-bottom:10px; border-bottom:1px solid var(--border)}
    .title{font-size:22px;font-weight:700;letter-spacing:.3px}
    .header-right{display:flex; align-items:center; gap:8px; color:var(--muted); font-size:12px}

    .small{font-size:12px;color:var(--muted)}
    .stack{display:flex;flex-direction:column;gap:16px}

    .card{background:var(--card);border:1px solid var(--border);border-radius:16px;box-shadow:0 8px 24px rgba(2,6,23,.06)}
    .card-header{display:flex;align-items:center;justify-content:space-between;padding:14px 14px;cursor:pointer;user-select:none}
    .card-title{font-weight:700;margin:0}
    .chev{display:inline-flex;align-items:center;justify-content:center;width:24px;height:24px;transition:transform .2s ease}
    .card.collapsed .chev{transform:rotate(-90deg)}
    .card-content{padding:0 14px 14px 14px}

    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .col{display:flex;flex-direction:column;gap:8px}
    label{font-size:12px;color:var(--muted)}
    input[type="text"],input[type="number"],select,textarea,input[type="month"]{
      width:100%;background:#ffffff;border:1px solid var(--border);color:var(--text);border-radius:12px;padding:12px 12px;font-size:15px;outline:none
    }
    textarea{min-height:88px;resize:vertical}
    .btn{border:1px solid transparent;background:linear-gradient(180deg,var(--accent),#1e4fd9);color:white;border-radius:12px;padding:12px 14px;font-weight:600;font-size:15px;cursor:pointer}
    .btn.alt{background:#f1f5f9;color:var(--text);border-color:var(--border)}
    .btn.ghost{background:transparent;border:1px solid var(--border);color:var(--text)}
    .btn.warn{background:linear-gradient(180deg,#ef4444,#dc2626); color:#fff; border:0;}
    .btn:active{transform:translateY(1px)}
    .chips{display:flex;gap:8px;flex-wrap:wrap}
    .chip{background:var(--chip);color:#1e3a8a;padding:8px 10px;border-radius:999px;border:1px solid #dbeafe;display:inline-flex;align-items:center;gap:8px}
    .chip .x{cursor:pointer;opacity:.8}
    table{width:100%;border-collapse:collapse;background:#fff}
    th,td{border-bottom:1px solid var(--border);padding:10px 8px;text-align:left;font-size:14px}
    th{color:var(--muted);font-weight:600;background:#f8fafc}
    tfoot td{font-weight:700;background:#f8fafc}
    .seg{display:flex;background:#f1f5f9;border:1px solid var(--border);border-radius:12px;overflow:hidden}
    .seg button{flex:1;background:transparent;border:0;color:var(--muted);padding:10px 12px;font-weight:600}
    .seg button.active{color:var(--text);background:#fff}
    .pill{font-weight:700;padding:4px 10px;border-radius:999px}
    .pill.ok{background:#ecfdf5;color:#065f46}
    .pill.bad{background:#fef2f2;color:#7f1d1d}
    .muted{color:var(--muted)}
    .right{margin-left:auto}
    .footer{color:var(--muted);text-align:center;margin:16px 0 24px}
    .note{font-size:12px;color:var(--muted)}
    .big{font-size:20px;font-weight:800}

    details{border:1px solid var(--border); border-radius:12px; background:#fff; padding:10px 12px}
    summary{font-weight:700; cursor:pointer; list-style:none}
    summary::-webkit-details-marker{display:none}
    .summary-row{display:flex; align-items:center; gap:8px}
    .tag{font-size:12px; padding:4px 8px; border:1px solid var(--border); border-radius:999px; background:#f8fafc}
  </style>
<link rel="manifest" href="/family-accounts/manifest.webmanifest" />
<meta name="theme-color" content="#0f172a" />
<link rel="icon" href="/family-accounts/favicon-32.png" sizes="32x32" />
<link rel="icon" href="/family-accounts/icon-192.png" sizes="192x192" />
<link rel="icon" href="/family-accounts/icon-512.png" sizes="512x512" />

<script>
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("/family-accounts/service-worker.js")
        .catch(err => console.error("SW registration failed:", err));
    });
  }
</script>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <div class="title">üè¶ Family Accounts</div>
      <div class="header-right">
        <span id="modeBadge">Mode: Local storage</span>
        <span>‚Ä¢</span>
        <span>Last edited: <span id="lastEdited">‚Äî</span></span>
      </div>
    </div>

    <div class="stack" style="margin-top:14px">
      <!-- Collapsible: File options -->
      <details>
        <summary>
          <div class="summary-row">
            <span>File options</span>
            <span class="tag" id="fileStatus">Local-only (no file)</span>
          </div>
        </summary>
        <div class="row" style="margin-top:8px">
          <button class="btn" id="chooseFileBtn" type="button">Choose / Open data file</button>
          <button class="btn ghost" id="createFileBtn" type="button">Create new data file</button>
          <button class="btn ghost" id="reopenBtn" type="button">Reopen last file</button>
          <button class="btn alt" id="importBtn" type="button">Import JSON (backup)</button>
          <input type="file" id="importInput" accept="application/json" style="display:none" />
          <button class="btn alt" id="exportBtn" type="button">Export JSON (backup)</button>
        </div>
        <div class="note">Tip: If you use a Drive JSON here, the app autosaves to it. Otherwise it saves locally in this browser. Export creates a full backup of all months.</div>
      </details>

      <!-- NEW: Month picker in its own box -->
      <div class="card" data-section="month">
        <div class="card-header"><div class="card-title">Month</div><div class="chev">‚ñ∏</div></div>
        <div class="card-content">
          <div class="col" style="max-width:220px">
            <label for="month">Select month</label>
            <input type="month" id="month" />
          </div>
        </div>
      </div>

      <div class="card" data-section="copy">
        <div class="card-header">
          <div class="card-title">Copy people & categories from another month</div>
          <div class="chev">‚ñ∏</div>
        </div>
        <div class="card-content">
          <div class="row">
            <div class="col" style="min-width:220px;flex:1">
              <label for="copySourceMonth">Source month</label>
              <select id="copySourceMonth"></select>
            </div>
            <button class="btn alt" id="copyMergeBtn" type="button" title="Keep current + add new from source">Copy (Merge)</button>
            <button class="btn ghost" id="copyOverwriteBtn" type="button" title="Replace current with source">Copy (Overwrite)</button>
          </div>
          <div class="note">Only people & categories are copied. Expenses are not changed.</div>
        </div>
      </div>

      <div class="card" data-section="people">
        <div class="card-header"><div class="card-title">People</div><div class="chev">‚ñ∏</div></div>
        <div class="card-content">
          <div class="row">
            <input id="personName" type="text" placeholder="e.g., Stuart" inputmode="text" autocomplete="off" />
            <button class="btn" id="addPersonBtn" type="button">Add person</button>
          </div>
          <div class="chips" id="peopleChips"></div>
        </div>
      </div>

      <div class="card" data-section="categories">
        <div class="card-header"><div class="card-title">Categories</div><div class="chev">‚ñ∏</div></div>
        <div class="card-content">
          <div class="row">
            <input id="categoryName" type="text" placeholder="e.g., Groceries" />
            <button class="btn" id="addCategoryBtn" type="button">Add category</button>
          </div>
          <div class="chips" id="categoriesChips"></div>
        </div>
      </div>

      <div class="card" data-section="add-expenses">
        <div class="card-header"><div class="card-title">Add expenses</div><div class="chev">‚ñ∏</div></div>
        <div class="card-content">
          <div class="seg" style="margin-bottom:10px">
            <button id="modeQuick" class="active" type="button">Quick add (same category)</button>
            <button id="modeBatch" type="button">Batch add (multiple categories)</button>
          </div>

          <div id="quickPanel">
            <div class="row">
              <div class="col" style="min-width:160px;flex:1">
                <label>Payer</label>
                <select id="quickPerson"></select>
              </div>
              <div class="col" style="min-width:160px;flex:1">
                <label>Category</label>
                <select id="quickCategory"></select>
              </div>
              <div class="col" style="min-width:180px;flex:1">
                <label>Split</label>
                <select id="quickSplit"></select>
              </div>
            </div>
            <div class="row">
              <div class="col" style="flex:1">
                <label>Amounts (comma / space / new line separated)</label>
                <textarea id="quickAmounts" placeholder="e.g., 12.50, 7, 19.99"></textarea>
                <div class="note">Tip: paste many numbers, one per line. Both "," and "." work as decimals.</div>
              </div>
            </div>
            <div class="row">
              <div class="col" style="flex:1">
                <label>Note (optional, applied to all)</label>
                <input id="quickNote" type="text" placeholder="e.g., supermarket run" />
              </div>
            </div>
            <div class="row">
              <button class="btn" id="addQuickBtn" type="button">Add expense(s)</button>
              <button class="btn ghost" id="clearQuickBtn" type="button">Clear</button>
            </div>
          </div>

          <div id="batchPanel" style="display:none">
            <div class="row">
              <div class="col" style="min-width:160px;flex:1">
                <label>Payer</label>
                <select id="batchPerson"></select>
              </div>
              <div class="col" style="min-width:180px;flex:1">
                <label>Split</label>
                <select id="batchSplit"></select>
              </div>
            </div>
            <div id="batchRows"></div>
            <div class="row">
              <button class="btn alt" id="addBatchRowBtn" type="button">+ Add another line</button>
              <div class="right"></div>
              <button class="btn" id="saveBatchBtn" type="button">Save all lines</button>
              <button class="btn ghost" id="clearBatchBtn" type="button">Clear lines</button>
            </div>
            <div class="note">Each line: choose a category and enter amount. Split applies to all lines here.</div>
          </div>
        </div>
      </div>

      <div class="card" data-section="all-expenses">
        <div class="card-header">
          <div class="card-title">All expenses</div>
          <div class="row">
            <button class="btn warn" id="clearMonthBtn" type="button">Clear this month‚Äôs expenses</button>
            <div class="chev">‚ñ∏</div>
          </div>
        </div>
        <div class="card-content">
          <div class="row" style="justify-content:space-between">
            <div class="muted">Tap üóëÔ∏è to remove a line</div>
          </div>
          <div id="expensesEmpty" class="muted" style="padding:6px 0 12px">No expenses yet.</div>
          <div style="overflow:auto">
            <table id="expensesTable" style="display:none">
              <thead>
                <tr><th>#</th><th>Payer</th><th>Category</th><th>Note</th><th>Amount</th><th>Split</th><th></th></tr>
              </thead>
              <tbody id="expensesBody"></tbody>
              <tfoot>
                <tr><td colspan="4">Total</td><td id="totalCell">‚Ç¨0.00</td><td></td><td></td></tr>
              </tfoot>
            </table>
          </div>
        </div>
      </div>

      <div class="card" data-section="totals-people">
        <div class="card-header"><div class="card-title">Totals by person</div><div class="chev">‚ñ∏</div></div>
        <div class="card-content"><div id="totalsPeople"></div></div>
      </div>

      <div class="card" data-section="totals-categories">
        <div class="card-header"><div class="card-title">Totals by category</div><div class="chev">‚ñ∏</div></div>
        <div class="card-content"><div id="totalsCategories"></div></div>
      </div>

      <div class="card" data-section="settlements">
        <div class="card-header"><div class="card-title">Who owes who</div><div class="chev">‚ñ∏</div></div>
        <div class="card-content">
          <div id="settlements"></div>
          <div class="note">Balances are based on what each person paid minus what they owed from the chosen splits. Positive balances mean others owe them; negative balances mean they owe others.</div>
        </div>
      </div>

      <div class="card" data-section="averages">
        <div class="card-header"><div class="card-title">Averages</div><div class="chev">‚ñ∏</div></div>
        <div class="card-content">
          <div class="row">
            <div class="col">
              <label>Average monthly spend ‚Äî YTD</label>
              <div id="avgYTD" class="big">‚Ç¨0.00</div>
            </div>
            <div class="col">
              <label>Average monthly spend ‚Äî All saved months</label>
              <div id="avgAll" class="big">‚Ç¨0.00</div>
            </div>
          </div>
          <div class="row" style="margin-top:10px">
            <div class="col" style="flex:1">
              <div class="card-title" style="font-weight:700">Average by category ‚Äî YTD</div>
              <div id="avgCatYTD"></div>
            </div>
            <div class="col" style="flex:1">
              <div class="card-title" style="font-weight:700">Average by category ‚Äî All</div>
              <div id="avgCatAll"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="footer">stuartscottAI</div>
    </div>
  </div>

  <script>
    // ---------- Core selectors ----------
    const monthEl = document.getElementById('month');
    const modeBadge = document.getElementById('modeBadge');
    const lastEditedEl = document.getElementById('lastEdited');

    const personNameEl = document.getElementById('personName');
    const addPersonBtn = document.getElementById('addPersonBtn');
    const peopleChips = document.getElementById('peopleChips');

    const categoryNameEl = document.getElementById('categoryName');
    const addCategoryBtn = document.getElementById('addCategoryBtn');
    const categoriesChips = document.getElementById('categoriesChips');

    const modeQuickBtn = document.getElementById('modeQuick');
    const modeBatchBtn = document.getElementById('modeBatch');
    const quickPanel = document.getElementById('quickPanel');
    const batchPanel = document.getElementById('batchPanel');

    const quickPerson = document.getElementById('quickPerson');
    theQuickCategory = document.getElementById('quickCategory'); // keep old id name; variable name typo fixed below
    const quickCategory = document.getElementById('quickCategory');
    const quickSplit = document.getElementById('quickSplit');
    const quickAmounts = document.getElementById('quickAmounts');
    const addQuickBtn = document.getElementById('addQuickBtn');
    const clearQuickBtn = document.getElementById('clearQuickBtn');

    const batchPerson = document.getElementById('batchPerson');
    const batchSplit = document.getElementById('batchSplit');
    const batchRows = document.getElementById('batchRows');
    const addBatchRowBtn = document.getElementById('addBatchRowBtn');
    const saveBatchBtn = document.getElementById('saveBatchBtn');
    const clearBatchBtn = document.getElementById('clearBatchBtn');

    const expensesEmpty = document.getElementById('expensesEmpty');
    const expensesTable = document.getElementById('expensesTable');
    const expensesBody = document.getElementById('expensesBody');
    const totalCell = document.getElementById('totalCell');

    const totalsPeople = document.getElementById('totalsPeople');
    const totalsCategories = document.getElementById('totalsCategories');
    const settlements = document.getElementById('settlements');

    const clearMonthBtn = document.getElementById('clearMonthBtn');

    // Averages
    const avgYTD = document.getElementById('avgYTD');
    const avgAll = document.getElementById('avgAll');
    const avgCatYTD = document.getElementById('avgCatYTD');
    const avgCatAll = document.getElementById('avgCatAll');

    // File & data mgmt selectors
    const chooseFileBtn = document.getElementById('chooseFileBtn');
    const createFileBtn = document.getElementById('createFileBtn');
    const reopenBtn = document.getElementById('reopenBtn');
    const fileStatus = document.getElementById('fileStatus');
    const importBtn = document.getElementById('importBtn');
    const exportBtn = document.getElementById('exportBtn');
    const importInput = document.getElementById('importInput');

    // ---------- App state ----------
    let data = null; // current month data
    let fileHandle = null; // FileSystemFileHandle
    let fileData = { months: {} }; // consolidated months when using a file
    let saveDebounce = null;
    const HANDLE_DB = 'famacct-db';
    const HANDLE_KEY = 'dataFile';
    let lastLoadedMonth = null;
    let lastMonthSnapshot = null; // for copying people/categories when creating new month

    // ---------- Utilities ----------
    function thisMonthValue(){
      const d = new Date();
      const m = String(d.getMonth()+1).padStart(2,'0');
      return `${d.getFullYear()}-${m}`;
    }
    function keyFor(month){ return `famacct:${month}` }
    function defaultData(copyFrom){
      return {people:(copyFrom?.people||[]), categories:(copyFrom?.categories||[]), expenses:[], lastEdited: new Date().toISOString()};
    }
    function euro(n){ return n.toLocaleString('es-ES',{style:'currency',currency:'EUR'}) }
    function round2(n){ return Math.round((n+Number.EPSILON)*100)/100 }
    function debounceSave(){ clearTimeout(saveDebounce); saveDebounce = setTimeout(()=>persist(), 400); }
    function setModeBadge(){ modeBadge.textContent = fileHandle ? `Mode: Drive file ‚Äî ${fileHandle.name}` : 'Mode: Local storage'; }
    function formatUK(iso){
      if(!iso) return '‚Äî';
      const d = new Date(iso);
      const dd = String(d.getDate()).padStart(2,'0');
      const mm = String(d.getMonth()+1).padStart(2,'0');
      const yyyy = d.getFullYear();
      const HH = String(d.getHours()).padStart(2,'0');
      const min = String(d.getMinutes()).padStart(2,'0');
      return `${dd}/${mm}/${yyyy} ${HH}:${min}`;
    }
    function setLastEditedNow(){ if(data){ data.lastEdited = new Date().toISOString(); renderLastEdited(); } }
    function renderLastEdited(){ lastEditedEl.textContent = formatUK(data?.lastEdited); }

    // ---------- Collapsible cards ----------
    const COLLAPSE_KEY = 'famacct:collapsed';
    function loadCollapsed(){ try{ return JSON.parse(localStorage.getItem(COLLAPSE_KEY)||'{}'); }catch{return {}}; }
    function saveCollapsed(obj){ try{ localStorage.setItem(COLLAPSE_KEY, JSON.stringify(obj)); }catch{} }
    function setupCollapsibles(){
      const state = loadCollapsed();
      document.querySelectorAll('.card[data-section]').forEach(card=>{
        const key = card.getAttribute('data-section');
        const header = card.querySelector('.card-header');
        const content = card.querySelector('.card-content');
        const collapsed = !!state[key];
        if(collapsed){ card.classList.add('collapsed'); content.style.display = 'none'; }
        header.addEventListener('click', (e)=>{
          if(e.target.closest('button')) return; // don‚Äôt collapse when clicking a button inside header
          const now = card.classList.toggle('collapsed');
          content.style.display = now ? 'none' : 'block';
          const st = loadCollapsed(); st[key] = now ? 1 : 0; saveCollapsed(st);
        });
      });
    }

    // ---------- Storage: Local ----------
    function localLoadMonth(month){
      const raw = localStorage.getItem(keyFor(month));
      if(raw){ 
        try{ data = JSON.parse(raw)||defaultData(null); }catch{ data = defaultData(null); } 
        if(!data.lastEdited){ data.lastEdited = new Date().toISOString(); }
      } else {
        data = defaultData(null);
        localStorage.setItem(keyFor(month), JSON.stringify(data));
      }
    }
    function localSaveCurrent(){ localStorage.setItem(keyFor(monthEl.value), JSON.stringify(data)); }
    function localMirrorAllFromFile(){
      const months = Object.keys(fileData.months||{});
      for(const m of months){
        try{ localStorage.setItem(keyFor(m), JSON.stringify(fileData.months[m])); }catch{}
      }
    }
    function listSavedMonthsLocal(){
      const months = [];
      for(let i=0;i<localStorage.length;i++){
        const k = localStorage.key(i);
        if(k && k.startsWith('famacct:')) months.push(k.split(':')[1]);
      }
      months.sort((a,b)=> a<b?1:(a>b?-1:0));
      return months;
    }

    // ---------- Storage: File ----------
    async function ensureRW(handle){
      if(!handle) return false;
      const p = await handle.queryPermission({mode:'readwrite'});
      if(p==='granted') return true;
      const req = await handle.requestPermission({mode:'readwrite'});
      return req==='granted';
    }
    async function readFileJSON(handle){
      const file = await handle.getFile();
      const text = await file.text();
      try{ return JSON.parse(text); }catch{ return {months:{}} }
    }
    async function writeFileJSON(handle, obj){
      const writable = await handle.createWritable();
      await writable.write(JSON.stringify(obj, null, 2));
      await writable.close();
    }
    function listSavedMonthsFile(){ return Object.keys(fileData.months||{}).sort((a,b)=> a<b?1:(a>b?-1:0)); }

    // ---------- IndexedDB handle store ----------
    function idbOpen(){
      return new Promise((resolve, reject)=>{
        const req = indexedDB.open(HANDLE_DB, 1);
        req.onupgradeneeded = ()=>{ const db = req.result; if(!db.objectStoreNames.contains('handles')) db.createObjectStore('handles'); };
        req.onsuccess = ()=>resolve(req.result);
        req.onerror = ()=>reject(req.error);
      });
    }
    async function idbSet(key, val){
      const db = await idbOpen();
      return new Promise((resolve,reject)=>{
        const tx = db.transaction('handles','readwrite');
        tx.objectStore('handles').put(val, key);
        tx.oncomplete = ()=>resolve();
        tx.onerror = ()=>reject(tx.error);
      });
    }
    async function idbGet(key){
      const db = await idbOpen();
      return new Promise((resolve,reject)=>{
        const tx = db.transaction('handles','readonly');
        const req = tx.objectStore('handles').get(key);
        req.onsuccess = ()=>resolve(req.result);
        req.onerror = ()=>reject(req.error);
      });
    }

    // ---------- Shared load/save ----------
    function monthExists(month){
      if(fileHandle) return !!(fileData.months && fileData.months[month]);
      return localStorage.getItem(keyFor(month)) != null;
    }

    async function loadFromFileOrLocal(month){
      if(fileHandle){
        data = fileData.months[month];
        if(!data){
          const localRaw = localStorage.getItem(keyFor(month));
          if(localRaw){
            try{ data = JSON.parse(localRaw); }catch{ data = defaultData(null); }
          } else {
            data = defaultData(null);
          }
        }
      } else {
        localLoadMonth(month);
      }
    }

    function persist(){
      try{ localSaveCurrent(); }catch{}
      if(fileHandle){
        fileData.months[monthEl.value] = data;
        writeFileJSON(fileHandle, fileData).then(()=>{
          fileStatus.textContent = `File: ${fileHandle.name} ‚Äî saved`;
        }).catch(err=>{
          console.error(err);
          fileStatus.textContent = `File: ${fileHandle.name} ‚Äî save failed (working locally)`;
        });
      }
      renderAverages();
    }

    // ---------- Copy people & categories from another month ----------
    function uniqueList(arr){ return Array.from(new Set((arr||[]).map(s=>String(s).trim()).filter(Boolean))); }
    function populateCopySource(){
      const sel = document.getElementById('copySourceMonth');
      if(!sel) return;
      const months = listSavedMonths().filter(m => m !== monthEl.value);
      sel.innerHTML = '';
      const opt0 = document.createElement('option'); opt0.value=''; opt0.textContent='‚Äî select month ‚Äî'; sel.appendChild(opt0);
      for(const m of months){ const o=document.createElement('option'); o.value=m; o.textContent=m; sel.appendChild(o); }
    }
    function copyPeopleCategoriesFrom(srcMonth, mode){
      if(!srcMonth){ alert('Choose a source month'); return; }
      if(srcMonth === monthEl.value){ alert('Source and current month are the same'); return; }
      const src = getMonthData(srcMonth);
      if(!src){ alert('No data found for that month'); return; }
      const srcPeople = uniqueList(src.people||[]);
      const srcCats = uniqueList(src.categories||[]);
      if(mode === 'overwrite'){
        data.people = srcPeople; data.categories = srcCats;
      }else{
        data.people = uniqueList([...(data.people||[]), ...srcPeople]);
        data.categories = uniqueList([...(data.categories||[]), ...srcCats]);
      }
      save(); renderAll();
      alert('Copied ' + (mode==='overwrite'?'(overwrite)':'(merge)') + ' from ' + srcMonth);
    }

    // ---------- Split helpers ----------
    function buildSplitOptions(selectEl){
      const ppl = data.people || [];
      selectEl.innerHTML='';
      if(ppl.length === 2){
        const [a,b] = ppl;
        [[`50_50`,`50/50`],[`100_${a}`,`${a} 100%`],[`100_${b}`,`${b} 100%`]].forEach(([v,l])=>{
          const o=document.createElement('option'); o.value=v; o.textContent=l; selectEl.appendChild(o);
        });
      } else {
        const o1=document.createElement('option'); o1.value='equal_all'; o1.textContent='Equal among all people'; selectEl.appendChild(o1);
        const o2=document.createElement('option'); o2.value='payer_100'; o2.textContent='Payer 100%'; selectEl.appendChild(o2);
      }
    }
    function computeSplitsFromChoice(choice, payer){
      const ppl = data.people || [];
      const splits = {};
      if(ppl.length === 2){
        const [a,b] = ppl;
        if(choice==='50_50'){ splits[a]=50; splits[b]=50; }
        else if(choice===`100_${a}`){ splits[a]=100; splits[b]=0; }
        else if(choice===`100_${b}`){ splits[a]=0; splits[b]=100; }
        else { splits[a]=50; splits[b]=50; }
      } else {
        if(choice==='payer_100' && payer){ ppl.forEach(p=>splits[p]= (p===payer?100:0)); }
        else { // equal_all
          const share = Math.floor(100/ppl.length);
          let sum=0; for(let i=0;i<ppl.length;i++){ splits[ppl[i]] = (i===ppl.length-1) ? 100-sum : share; sum+=share; }
        }
      }
      return splits;
    }
    function splitsToLabel(splits){
      const parts = Object.entries(splits||{}).filter(([_,v])=>v>0).map(([k,v])=>`${k} ${v}%`);
      return parts.join(' / ') || '‚Äî';
    }

    // ---------- Computations & Rendering ----------
    // CHANGED: computeTotals now shows what each person ACTUALLY PAID (sum by payer), not split shares
    function computeTotals(){
      const perPerson = Object.fromEntries((data.people||[]).map(p=>[p,0]));
      const perCategory = Object.fromEntries((data.categories||[]).map(c=>[c,0]));
      let grand=0;
      for(const e of (data.expenses||[])){
        const amount = +e.amount || 0;
        const payer = e.payer || e.person || '';
        if(!(payer in perPerson)) perPerson[payer]=0;
        perPerson[payer] = round2((perPerson[payer]||0) + amount);
        if(!(e.category in perCategory)) perCategory[e.category]=0;
        perCategory[e.category]+= amount;
        grand+= amount;
      }
      perPerson.__total = round2(grand);
      return {perPerson, perCategory};
    }

    // CHANGED: computeSettlements uses PAID vs OWED (OWED from splits), not equal-share-of-grand-total
    function computeSettlements(){
      const people = (data.people||[]);
      const paid = Object.fromEntries(people.map(p=>[p,0]));
      const owed = Object.fromEntries(people.map(p=>[p,0]));
      let grand = 0;

      for(const e of (data.expenses||[])){
        const amount = +e.amount || 0;
        const payer = e.payer || e.person || '';
        grand += amount;

        // what was actually paid
        if(!(payer in paid)) paid[payer]=0;
        paid[payer] = round2((paid[payer]||0) + amount);

        // liability owed according to splits
        const splits = e.splits || {[payer]:100};
        const entries = Object.entries(splits);
        let allocated = 0;
        entries.forEach(([p, pct], idx) => {
          if(!(p in owed)) owed[p]=0;
          let part = round2(amount * ((+pct || 0)/100));
          allocated = round2(allocated + part);
          if(idx === entries.length - 1){
            const remainder = round2(amount - allocated);
            part = round2(part + remainder);
          }
          owed[p] = round2((owed[p]||0) + part);
        });
      }

      const balances = people.map(p=>({ person:p, balance: round2((paid[p]||0) - (owed[p]||0)) }));

      // greedy settlement: debtors (negative) pay creditors (positive)
      const creditors = balances.filter(b=>b.balance>0).map(b=>({...b})).sort((a,b)=>b.balance-a.balance);
      const debtors = balances.filter(b=>b.balance<0).map(b=>({...b})).sort((a,b)=>a.balance-b.balance);
      const transfers = [];
      let ci=0, di=0;
      while(ci<creditors.length && di<debtors.length){
        const c = creditors[ci], d = debtors[di];
        const amt = round2(Math.min(c.balance, -d.balance));
        if(amt>0){
          transfers.push({from:d.person,to:c.person,amount:amt});
          c.balance = round2(c.balance - amt);
          d.balance = round2(d.balance + amt);
        }
        if(c.balance<=0.0001) ci++;
        if(d.balance>=-0.0001) di++;
      }
      // Share kept ONLY for existing UI display; not used in balance math
      const n = people.length || 1;
      const share = round2((grand||0)/n);
      return {share, balances, transfers};
    }

    function renderPeopleCats(){
      peopleChips.innerHTML = '';
      for(const p of (data.people||[])){
        const c = document.createElement('span');
        c.className='chip';
        c.innerHTML = '<span>'+p+'</span><span class="x" title="Remove">‚úñ</span>';
        c.querySelector('.x').addEventListener('click',()=>{ if(confirm('Remove '+p+' and their expenses?')) { removePerson(p); }});
        peopleChips.appendChild(c);
      }
      categoriesChips.innerHTML = '';
      for(const cName of (data.categories||[])){
        const c = document.createElement('span');
        c.className='chip';
        c.innerHTML = '<span>'+cName+'</span><span class="x" title="Remove">‚úñ</span>';
        c.querySelector('.x').addEventListener('click',()=>{ if(confirm('Remove category \"'+cName+'\" and related expenses?')) { removeCategory(cName); }});
        categoriesChips.appendChild(c);
      }
      fillSelect(quickPerson, (data.people||[]));
      fillSelect(quickCategory, (data.categories||[]));
      fillSelect(batchPerson, (data.people||[]));
      buildSplitOptions(quickSplit);
      buildSplitOptions(batchSplit);
      [...batchRows.querySelectorAll('.batchCategory')].forEach(sel=>fillSelect(sel, (data.categories||[])));
    }
    function renderExpenses(){
      if(!(data.expenses||[]).length){
        expensesEmpty.style.display='block';
        expensesTable.style.display='none';
        totalCell.textContent = euro(0);
        expensesBody.innerHTML = '';
        return;
      }
      expensesEmpty.style.display='none';
      expensesTable.style.display='table';
      expensesBody.innerHTML = '';
      let i=1, total=0;
      for(const [idx,e] of (data.expenses||[]).entries()){
        total += (+e.amount||0);
        const tr = document.createElement('tr');
        const payer = e.payer || e.person || '';
        const splitTxt = splitsToLabel(e.splits||{[payer]:100});
        tr.innerHTML = '<td>'+ (i++) +'</td><td>'+payer+'</td><td>'+e.category+'</td><td>'+(e.note?String(e.note).replace(/</g,'&lt;'):'')+'</td><td>'+euro(+e.amount||0)+'</td><td>'+splitTxt+'</td><td><button class="btn ghost" title="Delete" data-i="'+idx+'" type="button">üóëÔ∏è</button></td>';
        tr.querySelector('button').addEventListener('click',()=>{ (data.expenses||[]).splice(idx,1); save(); renderAll(); });
        expensesBody.appendChild(tr);
      }
      totalCell.textContent = euro(round2(total));
    }
    function renderTotals(){
      const {perPerson, perCategory} = computeTotals();
      const total = perPerson.__total || 0;
      let htmlP='';
      if((data.people||[]).length){
        htmlP += '<table><thead><tr><th>Person</th><th>Total paid this month</th></tr></thead><tbody>';
        for(const p of (data.people||[])){
          htmlP += '<tr><td>'+p+'</td><td>'+euro(round2(perPerson[p]||0))+'</td></tr>';
        }
        htmlP += '</tbody><tfoot><tr><td>All people</td><td>'+euro(round2(total))+'</td></tr></tfoot></table>';
      } else htmlP = '<div class="muted">Add some people to see totals.</div>';
      totalsPeople.innerHTML = htmlP;

      let htmlC='';
      if((data.categories||[]).length){
        htmlC += '<table><thead><tr><th>Category</th><th>Total</th></tr></thead><tbody>';
        for(const c of (data.categories||[])){
          htmlC += '<tr><td>'+c+'</td><td>'+euro(round2(perCategory[c]||0))+'</td></tr>';
        }
        htmlC += '</tbody><tfoot><tr><td>All categories</td><td>'+euro(round2(total))+'</td></tr></tfoot></table>';
      } else htmlC = '<div class="muted">Add some categories to see totals.</div>';
      totalsCategories.innerHTML = htmlC;
    }
    function renderSettlements(){
      const {share, balances, transfers} = computeSettlements();
      if(!(data.people||[]).length){ settlements.innerHTML = '<div class="muted">Add people first.</div>'; return; }
      let html = '<div class="row"><div>Equal share per person (based on splits): <strong>'+euro(share)+'</strong></div></div>';
      html += '<table><thead><tr><th>Person</th><th>Balance (positive = others owe them, negative = they owe others)</th></tr></thead><tbody>';
      for(const b of balances){
        const cls = b.balance>=0? 'ok' : 'bad';
        html += '<tr><td>'+b.person+'</td><td><span class="pill '+cls+'">'+(b.balance>=0?'+':'')+euro(b.balance)+'</span></td></tr>';
      }
      html += '</tbody></table>';
      if(!transfers.length){ html += '<div class="muted">No transfers needed ‚úÖ</div>'; }
      else{
        html += '<div class="card-title" style="margin:8px 0">Suggested transfers</div>';
        html += '<table><thead><tr><th>From</th><th>To</th><th>Amount</th></tr></thead><tbody>';
        for(const t of transfers){ html += '<tr><td>'+t.from+'</td><td>'+t.to+'</td><td>'+euro(t.amount)+'</td></tr>'; }
        html += '</tbody></table>';
      }
      settlements.innerHTML = html;
    }
    function renderAll(){
      renderPeopleCats(); renderExpenses(); renderTotals(); renderSettlements(); renderLastEdited();
    }

    function fillSelect(selectEl, items){
      selectEl.innerHTML = '';
      const opt = document.createElement('option'); opt.value=''; opt.textContent='‚Äî select ‚Äî'; selectEl.appendChild(opt);
      for(const it of (items||[])){ const o = document.createElement('option'); o.value=it; o.textContent=it; selectEl.appendChild(o); }
    }

    // Averages across months (from local or file)
    function listSavedMonths(){ return fileHandle ? listSavedMonthsFile() : listSavedMonthsLocal(); }
    function getMonthData(m){
      if(fileHandle) return fileData.months[m] || defaultData(null);
      const raw = localStorage.getItem(keyFor(m)); if(!raw) return defaultData(null);
      try{ return JSON.parse(raw); }catch{return defaultData(null);} }
    function computeAverages(){
      const months = listSavedMonths();
      const allData = months.map(m=>({m, d:getMonthData(m)})).filter(x=>x.d);
      const year = new Date().getFullYear();
      const ytd = allData.filter(x => x.m.startsWith(year + '-'));
      const allMonthsCount = allData.length, ytdMonthsCount = ytd.length;
      const sumTotal = (arr)=> arr.reduce((s,x)=> s + (x.d.expenses||[]).reduce((a,e)=>a+(+e.amount||0),0), 0);
      const totalAll = sumTotal(allData), totalYTD = sumTotal(ytd);
      const avgAllVal = allMonthsCount ? round2(totalAll / allMonthsCount) : 0;
      const avgYTDVal = ytdMonthsCount ? round2(totalYTD / ytdMonthsCount) : 0;
      const catsAllTotals = {}, catsYtdTotals = {}; const catSetAll = new Set(), catSetYTD = new Set();
      allData.forEach(({d})=>{ (d.categories||[]).forEach(c=>catSetAll.add(c)); (d.expenses||[]).forEach(e=>{ catsAllTotals[e.category]=(catsAllTotals[e.category]||0)+(+e.amount||0); }); });
      ytd.forEach(({d})=>{ (d.categories||[]).forEach(c=>catSetYTD.add(c)); (d.expenses||[]).forEach(e=>{ catsYtdTotals[e.category]=(catsYtdTotals[e.category]||0)+(+e.amount||0); }); });
      const avgCatAllMap = {}, avgCatYTDMap = {};
      for(const c of catSetAll){ avgCatAllMap[c] = allMonthsCount ? round2((catsAllTotals[c]||0)/allMonthsCount) : 0; }
      for(const c of catSetYTD){ avgCatYTDMap[c] = ytdMonthsCount ? round2((catsYtdTotals[c]||0)/ytdMonthsCount) : 0; }
      return {avgAllVal, avgYTDVal, avgCatAllMap, avgCatYTDMap, allMonthsCount, ytdMonthsCount};
    }
    function tableFromMap(mapObj, leftHeader, rightHeader){
      const keys = Object.keys(mapObj).sort((a,b)=> mapObj[b]-mapObj[a]); if(!keys.length) return '<div class="muted">No data yet.</div>';
      let html = '<table><thead><tr><th>'+leftHeader+'</th><th>'+rightHeader+'</th></tr></thead><tbody>';
      for(const k of keys){ html += '<tr><td>'+k+'</td><td>'+euro(mapObj[k])+'</td></tr>'; }
      html += '</tbody></table>'; return html;
    }
    function renderAverages(){
      const {avgAllVal, avgYTDVal, avgCatAllMap, avgCatYTDMap, allMonthsCount, ytdMonthsCount} = computeAverages();
      avgAll.textContent = euro(avgAllVal) + (allMonthsCount?(' ('+allMonthsCount+' mo.)'):'');
      avgYTD.textContent = euro(avgYTDVal) + (ytdMonthsCount?(' ('+ytdMonthsCount+' mo. YTD)'):'');
      avgCatAll.innerHTML = tableFromMap(avgCatAllMap, 'Category', 'Avg / month (All)');
      avgCatYTD.innerHTML = tableFromMap(avgCatYTDMap, 'Category', 'Avg / month (YTD)');
    }

    // ---------- File & data mgmt ----------
    function updateFileStatus(){
      if(fileHandle){ fileStatus.textContent = 'File: '+fileHandle.name; }
      else { fileStatus.textContent = 'Local-only (no file)'; }
      setModeBadge();
      populateCopySource();
    }

    function mergeCurrentMonthLocalIntoFile(){
      const m = monthEl.value;
      if(!fileHandle) return;
      if(fileData.months[m]) return; // file already has it
      const raw = localStorage.getItem(keyFor(m));
      if(!raw) return;
      try{ const local = JSON.parse(raw); fileData.months[m] = local; }catch{}
    }

    async function chooseOpenFile(){
      try{
        if(!window.showOpenFilePicker){ alert('Your browser does not support this file picker. Use Import JSON instead.'); return; }
        const [h] = await window.showOpenFilePicker({ multiple:false, types:[{description:'JSON', accept:{'application/json':['.json']}}] });
        if(!h) return;
        if(!(await ensureRW(h))) { alert('No permission to read/write this file.'); return; }
        fileHandle = h;
        fileData = await readFileJSON(fileHandle);
        if(!fileData || typeof fileData!=='object' || !fileData.months){ fileData = {months:{}}; }
        mergeCurrentMonthLocalIntoFile();
        await writeFileJSON(fileHandle, fileData);
        localMirrorAllFromFile();
        await idbSet(HANDLE_KEY, fileHandle);
        updateFileStatus();
        await loadFromFileOrLocal(monthEl.value);
        renderAll(); renderAverages();
      }catch(e){ /* canceled */ }
    }

    async function createNewFile(){
      try{
        if(!window.showSaveFilePicker){ alert('Your browser does not support creating files here. Use Export JSON to create one.'); return; }
        const h = await window.showSaveFilePicker({ suggestedName:'family-accounts.json', types:[{description:'JSON', accept:{'application/json':['.json']}}] });
        if(!(await ensureRW(h))) { alert('No permission to write this file.'); return; }
        fileHandle = h; fileData = {months:{}};
        mergeCurrentMonthLocalIntoFile();
        await writeFileJSON(fileHandle, fileData);
        await idbSet(HANDLE_KEY, fileHandle);
        updateFileStatus();
        await loadFromFileOrLocal(monthEl.value);
        renderAll(); renderAverages();
      }catch(e){ /* canceled */ }
    }

    async function reopenLastFile(){
      try{
        const h = await idbGet(HANDLE_KEY);
        if(!h){ alert('No stored file handle yet. Choose a data file first.'); return; }
        if(!(await ensureRW(h))) { alert('Permission to the previous file was revoked. Please choose it again.'); return; }
        fileHandle = h;
        fileData = await readFileJSON(fileHandle);
        if(!fileData || typeof fileData!=='object' || !fileData.months){ fileData = {months:{}}; }
        mergeCurrentMonthLocalIntoFile();
        await writeFileJSON(fileHandle, fileData);
        localMirrorAllFromFile();
        updateFileStatus();
        await loadFromFileOrLocal(monthEl.value);
        renderAll(); renderAverages();
      }catch(e){
        alert('Could not reopen last file. Please choose it again.');
      }
    }

    // Import / Export
    function importJSON(obj){
  function normaliseMonth(x){
    if(!x || typeof x !== 'object') return {people:[], categories:[], expenses:[], lastEdited:new Date().toISOString()};
    const src = x.data && typeof x.data==='object' ? x.data : x;
    return {
      people: Array.isArray(src.people) ? src.people.map(String) : [],
      categories: Array.isArray(src.categories) ? src.categories.map(String) : [],
      expenses: Array.isArray(src.expenses) ? src.expenses.map(e=>({
        payer: e.payer || e.person || '',
        category: e.category || '',
        amount: typeof e.amount === 'string' ? parseFloat(e.amount.replace(',','.')) : (+e.amount||0),
        note: e.note || '',
        splits: (e.splits && typeof e.splits==='object') ? e.splits : (e.payer||e.person ? {[e.payer||e.person]:100} : {})
      })) : [],
      lastEdited: src.lastEdited || new Date().toISOString()
    };
  }

  const nowMonth = monthEl.value || thisMonthValue();

  if(obj && obj.months && typeof obj.months === 'object'){
    for(const [m, val] of Object.entries(obj.months)){
      fileData.months[m] = normaliseMonth(val);
    }
  } else if (obj && (obj.people || obj.categories || obj.expenses || obj.data)){
    fileData.months[nowMonth] = normaliseMonth(obj);
  } else {
    throw new Error('This file is valid JSON but not a recognised Family Accounts export.');
  }

  for(const m of Object.keys(fileData.months)){
    try{ localStorage.setItem(keyFor(m), JSON.stringify(fileData.months[m])); }catch{}
  }
  if(fileHandle){ writeFileJSON(fileHandle, fileData).catch(()=>{}); }
  if(fileData.months[nowMonth]){ data = fileData.months[nowMonth]; }
  renderAll();
  renderAverages();
}

importBtn.addEventListener('click', ()=> importInput.click());

importInput.addEventListener('change', async (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  try{
    const rawText = await f.text();
    const text = String(rawText).replace(/^\uFEFF/, '').trim();

    const head = text.slice(0, 200).toLowerCase();
    if(head.includes('<!doctype') || head.includes('<html')){
      alert('That file looks like an HTML page, not JSON. If downloading from GitHub, click "Raw" before saving.');
      return;
    }

    let obj;
    try {
      obj = JSON.parse(text);
    } catch {
      const stripped = text.replace(/\/\*[\s\S]*?\*\//g, '').replace(/(^|[^:])\/\/.*$/gm, '$1');
      obj = JSON.parse(stripped);
    }

    importJSON(obj);
    alert('Import complete!');

  }catch(err){
    alert('Could not read that JSON.');
    console.error(err);
  } finally {
    importInput.value = '';
  }
});


    // ---------- Month switching ----------
    async function switchMonthSafely(targetMonth){
      if(targetMonth === lastLoadedMonth) return;
      lastMonthSnapshot = data ? {people:[...(data.people||[])], categories:[...(data.categories||[])]} : null;
      if(monthExists(targetMonth)){
        await loadFromFileOrLocal(targetMonth);
      } else {
        const base = lastMonthSnapshot || {people:[], categories:[]};
        const fresh = defaultData(base);
        if(fileHandle){ fileData.months[targetMonth] = fresh; await writeFileJSON(fileHandle, fileData); }
        else { localStorage.setItem(keyFor(targetMonth), JSON.stringify(fresh)); }
        data = fresh;
      }
      lastLoadedMonth = targetMonth;
      monthEl.value = targetMonth;
      renderLastEdited();
      persist();
      renderAll();
    }

    // ---------- Public actions ----------
    function setMonthToNow(){ monthEl.value = thisMonthValue(); }
    function loadMonth(month){ loadFromFileOrLocal(month).then(()=>{ renderAll(); renderAverages(); }); }

    function save(){ setLastEditedNow(); persist(); }
    function addPerson(name){
      name = (name||'').trim(); if(!name) return; if((data.people||[]).includes(name)) return;
      (data.people = data.people||[]).push(name); save(); renderPeopleCats();
    }
    function removePerson(name){
      data.people = (data.people||[]).filter(p=>p!==name);
      data.expenses = (data.expenses||[]).filter(e=>e.payer!==name && e.person!==name);
      save(); renderAll();
    }
    function addCategory(name){
      name = (name||'').trim(); if(!name) return; if((data.categories||[]).includes(name)) return;
      (data.categories = data.categories||[]).push(name); save(); renderPeopleCats();
    }
    function removeCategory(name){
      data.categories = (data.categories||[]).filter(c=>c!==name);
      data.expenses = (data.expenses||[]).filter(e=>e.category!==name);
      save(); renderAll();
    }
    function parseAmounts(text){
      const tokens = String(text).split(/[\s,;]+/).map(t=>t.trim()).filter(Boolean);
      const nums = [];
      for(const t of tokens){ const cleaned=t.replace(/\u20ac/g,'').replace(/,/g,'.'); const n=parseFloat(cleaned); if(!isNaN(n)) nums.push(n); }
      return nums;
    }

    function addQuickExpenses(){
      const payer = quickPerson.value;
      const category = quickCategory.value;
      if(!payer || !category){ alert('Please select a person and category'); return; }
      const amounts = parseAmounts(quickAmounts.value);
      if(!amounts.length){ alert('Add at least one amount'); return; }
      const note = document.getElementById('quickNote') ? document.getElementById('quickNote').value.trim() : '';
      const choice = quickSplit.value || '50_50';
      const splits = computeSplitsFromChoice(choice, payer);
      for(const a of amounts){ if(a<=0) continue; (data.expenses = data.expenses||[]).push({payer, category, amount: round2(+a), note, splits}); }
      save(); renderAll(); quickAmounts.value='';
    }

    function makeBatchRow(category=''){
      const row=document.createElement('div'); row.className='row';
      row.innerHTML='\
        <div class="col" style="flex:1;min-width:160px"><label>Category</label><select class="batchCategory"></select></div>\
        <div class="col" style="width:160px"><label>Amount</label><input class="batchAmount" type="number" inputmode="decimal" step="0.01" placeholder="0.00"/></div>\
        <div class="col" style="flex:1;min-width:200px"><label>Note (optional)</label><input class="batchNote" type="text" placeholder="e.g., receipt #1234"/></div>\
        <button class="btn ghost removeRowBtn" type="button" title="Remove">üóëÔ∏è</button>';
      const sel=row.querySelector('.batchCategory'); fillSelect(sel, (data.categories||[])); if(category) sel.value=category;
      row.querySelector('.removeRowBtn').addEventListener('click',()=>row.remove());
      return row;
    }
    function saveBatch(){
      const payer=batchPerson.value; if(!payer){ alert('Select a person'); return; }
      const rows=[...batchRows.querySelectorAll('.row')]; if(!rows.length){ alert('Add at least one line'); return; }
      const choice = batchSplit.value || '50_50';
      const splits = computeSplitsFromChoice(choice, payer);
      let added=0;
      for(const r of rows){
        const cat=r.querySelector('.batchCategory').value;
        const val=parseFloat(r.querySelector('.batchAmount').value);
        const note=(r.querySelector('.batchNote')?.value||'').trim();
        if(cat && isFinite(val) && val>0){ (data.expenses = data.expenses||[]).push({payer, category:cat, amount: round2(val), note, splits}); added++; }
      }
      if(!added){ alert('Please enter valid amounts'); return; }
      batchRows.innerHTML=''; save(); renderAll();
    }

    // ---------- Init & events ----------
    document.addEventListener('DOMContentLoaded', async ()=>{
      const initial = thisMonthValue();
      monthEl.value = initial;
      await loadFromFileOrLocal(initial);
      lastLoadedMonth = initial;
      lastMonthSnapshot = data ? {people:[...(data.people||[])], categories:[...(data.categories||[])]} : null;
      setupCollapsibles();
      renderAll();
      renderAverages();
      setModeBadge();
      populateCopySource();

      document.getElementById('copyMergeBtn').addEventListener('click', ()=>{
        const src = document.getElementById('copySourceMonth').value; copyPeopleCategoriesFrom(src, 'merge');
      });
      document.getElementById('copyOverwriteBtn').addEventListener('click', ()=>{
        const src = document.getElementById('copySourceMonth').value; if(!src) return alert('Choose a source month');
        if(confirm('Replace current people & categories with those from '+src+'?')) copyPeopleCategoriesFrom(src, 'overwrite');
      });

      monthEl.addEventListener('change', async ()=>{
        populateCopySource();
        const target = monthEl.value;
        await switchMonthSafely(target);
        buildSplitOptions(quickSplit);
        buildSplitOptions(batchSplit);
      });

      addPersonBtn.addEventListener('click', ()=>{
        const v = personNameEl.value; personNameEl.value=''; addPerson(v); personNameEl.focus();
        buildSplitOptions(quickSplit); buildSplitOptions(batchSplit);
      });
      personNameEl.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ addPersonBtn.click(); }});

      addCategoryBtn.addEventListener('click', ()=>{
        const v = categoryNameEl.value; categoryNameEl.value=''; addCategory(v); categoryNameEl.focus();
      });

      modeQuickBtn.addEventListener('click', ()=>{
        modeQuickBtn.classList.add('active'); modeBatchBtn.classList.remove('active');
        quickPanel.style.display='block'; batchPanel.style.display='none';
      });
      modeBatchBtn.addEventListener('click', ()=>{
        modeBatchBtn.classList.add('active'); modeQuickBtn.classList.remove('active');
        quickPanel.style.display='none'; batchPanel.style.display='block';
        if(!batchRows.children.length) batchRows.appendChild(makeBatchRow());
      });

      addQuickBtn.addEventListener('click', addQuickExpenses);
      clearQuickBtn.addEventListener('click', ()=>{ quickAmounts.value=''; });

      addBatchRowBtn.addEventListener('click', ()=> batchRows.appendChild(makeBatchRow()));
      saveBatchBtn.addEventListener('click', saveBatch);
      clearBatchBtn.addEventListener('click', ()=>{ batchRows.innerHTML=''; });

      clearMonthBtn.addEventListener('click', ()=>{
        const msg = "Are you sure you want to delete this month's expenses? You won't be able to get them back.";
        if(confirm(msg)){
          const m = monthEl.value;
          const safeName = (s)=> s.replace(/[^A-Za-z0-9_\-]/g,'-');
          const monthLabel = new Date(m + '-01T00:00:00').toLocaleString('en-GB',{month:'long', year:'numeric'}).replace(' ', '-');
          const backup = {months:{}}; backup.months[m] = JSON.parse(JSON.stringify(data));
          const blob = new Blob([JSON.stringify(backup, null, 2)], {type:'application/json'});
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a'); a.href=url; a.download=`family-accounts-backup-${safeName(monthLabel)}.json`;
          document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
          data.expenses = []; save(); renderAll();
        }
      });

      chooseFileBtn.addEventListener('click', chooseOpenFile);
      createFileBtn.addEventListener('click', createNewFile);
      reopenBtn.addEventListener('click', reopenLastFile);

      // Auto-reopen last file if permission remains
      try{
        const h = await idbGet(HANDLE_KEY);
        if(h){
          const ok = await h.queryPermission({mode:'readwrite'});
          if(ok==='granted'){
            fileHandle = h; fileData = await readFileJSON(fileHandle);
            mergeCurrentMonthLocalIntoFile();
            await writeFileJSON(fileHandle, fileData);
            localMirrorAllFromFile();
            updateFileStatus();
            await loadFromFileOrLocal(initial);
            lastLoadedMonth = initial;
            renderAll();
            renderAverages();
          }
        }
      }catch{}

      // initial split options
      buildSplitOptions(quickSplit);
      buildSplitOptions(batchSplit);
    });
  </script>
</body>
</html>
